REM >!Clipboard
REM
REM Copyright 2020, Stephen Fryatt (info@stevefryatt.org.uk)
REM
REM This file is part of Clipper:
REM
REM   http://www.stevefryatt.org.uk/software/
REM
REM Licensed under the EUPL, Version 1.1 only (the "Licence");
REM You may not use this work except in compliance with the
REM Licence.
REM
REM You may obtain a copy of the Licence at:
REM
REM   http://joinup.ec.europa.eu/software/page/eupl
REM
REM Unless required by applicable law or agreed to in
REM writing, software distributed under the Licence is
REM distributed on an "AS IS" basis, WITHOUT WARRANTIES
REM OR CONDITIONS OF ANY KIND, either express or implied.
REM
REM See the Licence for the specific language governing
REM permissions and limitations under the Licence.


REM Initialise the state of the clipboard monitor.
:
DEF PROCclipboard_initialise

REM An internal handle used to identify protocol errors.
ClipboardInternalHandle% = -&11223344

REM The current task which owns the clipboard.
ClipboardCurrentOwnerTask% = -1

REM The current type of the clipboard contents.
ClipboardCurrentType% = -1

REM The handle of the task to which we're saving the clipboard.
ClipboardSaveDestinationTask% = -1

REM The path on which we're saving the clipboard data.
ClipboardSavePath$ = ""

REM The last MyRef of the current examine operation.
ClipboardExamineMyRef% = -1

REM The last MyRef of the current request operation.
ClipboardRequestMyRef% = -1

REM The last MyRef of the drag save operation.
ClipboardDragSaveMyRef% = -1

REM The file holding the clipboard data if we own it.
ClipboardCurrentFile$ = ""

REM The MyRef of the last datasave message that we've sent.
ClipboardSaveMyRef% = -1
ENDPROC


REM Handle an incoming Message_ClaimEntity, which probably means that
REM the task owning the clipboard has changed. If it does, we drop any
REM record of the clipboard data, and enquire as to where the data is
REM now held.
REM
REM \param message%	Pointer to the Wimp_Poll block.
:
DEF PROCclipboard_message_claim_entity(message%)

REM We're not interested if this isn't a clipboard claim

IF (message%!20 AND %100) = 0 THEN ENDPROC

REM If the broadcast isn't from us, forget the current owner and
REM enquire as to where the clipboard now is.

IF message%!4 <> ClipperTaskHandle% THEN
	ClipboardCurrentOwnerTask% = -1
	ClipboardCurrentType% = -1
	ClipboardCurrentFile$ = ""
	PROCclipboard_examine
ENDIF
ENDPROC


REM Examine the current state of the clipboard in order to identify the
REM owner and the content.
REM
REM A Message_DataRequest is broadcast, which will result in a
REM Message_DataSave being sent back.
:
DEF PROCclipboard_examine
REM There's no point doing anything if we own the clipboard.
IF ClipboardCurrentOwnerTask% = ClipperTaskHandle% THEN ENDPROC

REM Send a Message_DataRequest to whoever currently owns the clipboard.

q%!0 = 44
q%!12 = 0
q%!16 = &10			: REM Message_DataRequest
q%!20 = MainWindHandle%
q%!24 = ClipboardInternalHandle%
q%!36 = %100			: REM Flags: Send Clipboard
q%!40 = -1			: REM No preferred type: send native format.
SYS "Wimp_SendMessage", 18, q%, 0

REM Clipboard Examine Step 1 -- Send Message_DataRequest

ClipboardExamineMyRef% = q%!8

PROCmain_wind_reset_proto
PROCmain_wind_set_proto_message("SearchOwner")
ENDPROC


REM Following our file icon being dragged to a save target, send a
REM Message_DataSave to the target window and icon to see if the
REM other task is interested in responding.
REM
REM \param xpos%	The X position of the save target.
REM \param ypos%	The Y position of the save target.
REM \param name$	The leafname of the file to be saved.
REM \param window%	The window containing the save target.
REM \param icon%	The icon containing the save target.
:
DEF PROCclipboard_start_drag_save(xpos%, ypos%, name$, window%, icon%)
b%!0 = (48 + LEN(name$)) AND &FC
b%!12 = 0
b%!16 = 1 : REM Message_DataSave
b%!20 = window%
b%!24 = icon%
b%!28 = xpos%
b%!32 = ypos%
b%!36 = 0
b%!40 = ClipboardCurrentType%
$(b%+44) = name$ + CHR$(0)
SYS "Wimp_SendMessage", 18, b%, window%, icon% TO ,,ClipboardSaveDestinationTask%

REM Clipboard Drag Save Step 1 - Send Message_DataSave

ClipboardDragSaveMyRef% = b%!8

PROCmain_wind_reset_proto
PROCmain_wind_set_proto_param_message("OfferData", FNclipboard_task_name_from_handle(ClipboardSaveDestinationTask%))
ENDPROC


REM Handle an inoming Message_DataRequest, which is a task asking us
REM if we own the clipboard.
REM
REM \param message%	Pointer to the Wimp_Poll block.
:
DEF PROCclipboard_message_data_request(message%)
LOCAL flags%, message$, leaf$, sender_handle%, object%, size%, type%

CASE message%!12 OF
WHEN ClipboardExamineMyRef%
	REM This is a broadcast message that we've sent as part of the
	REM examine process. Ignore.

	PROCmain_wind_set_proto_message("ItsOurs")

WHEN 0
	REM A request from another task, looking for the clipboard. If we
	REM don't own it, then we don't reply.

	IF ClipboardCurrentOwnerTask% <> ClipperTaskHandle% THEN ENDPROC

	REM We own the clipboard...

	PROCmain_wind_reset_proto
	PROCmain_wind_set_proto_message("SendingData")

	REM Ack the incoming message.

	sender_handle% = message%!4
	message%!12 = message%!8
	SYS "Wimp_SendMessage", 19, message%

	REM Get the details of our clipboard file.

	SYS "XOS_File", 23, ClipboardCurrentFile$ TO object%,,,,size%,,type% ;flags%

	IF (flags% AND %1) OR (object% <> 1) THEN
		message$ = FNmessage_lookup("BadClipFileErr")
		PROCwimperror_report(message$, 2, %10, "")
		ENDPROC
	ENDIF

	REM Send a Message_DataSave back as a response.

	leaf$ = FNstring_leafname(ClipboardCurrentFile$)

	message%!0 = 44 + (LEN(leaf$) + 4) AND &FC
	message%!16 = 1	: REM Message_DataSave
	message%!36 = size%
	message%!40 = type%
	$(message% + 44) = leaf$ + CHR$(0)
	SYS "Wimp_SendMessage", 17, message%, sender_handle%

	ClipboardRequestMyRef% = message%!8

OTHERWISE
	PROCmain_wind_set_proto_error("BadYourRef", "DataRequest")
ENDCASE
ENDPROC


REM Handle an incoming Message_DataSave, which a response to a
REM Message_DataRequest that we've sent: either to identify the
REM clipboard owner, or to request the clipboard data to save. 
REM
REM \param message%	Pointer to the Wimp_Poll block.
:
DEF PROCclipboard_message_data_save(message%)
LOCAL sender_handle%, task$

CASE message%!12 OF
WHEN ClipboardSaveMyRef%
	sender_handle% = message%!4
	message%!12 = message%!8
	message%!16 = 2 : REM Message_DataSaveAck
	$(message% + 44) = ClipboardSavePath$ + CHR$(0)
	message%!0 = (LEN(ClipboardSavePath$) + 48) AND &FC
	SYS "Wimp_SendMessage", 17, message%, sender_handle%
	ClipboardSaveMyRef% = message%!8

WHEN ClipboardExamineMyRef%
	REM A response to a Message_DataRequest sent by PROCclipboard_examine
	REM to identify the current owner of the clipboard.

	task$ = FNclipboard_task_name_from_handle(message%!4)

	IF message%!24 <> ClipboardInternalHandle% THEN
		PROCmain_wind_set_proto_param_error("BadHandle", task$)
	ELSE
		PROCmain_wind_set_proto_param_message("FoundOwner", task$)
	ENDIF

	REM Record the details of the current clipboard owner.

	ClipboardCurrentOwnerTask% = message%!4
	ClipboardCurrentType% = message%!40
	PROCmain_wind_set_content(FNstring_read(message%+44), task$, ClipboardCurrentType%)

	ClipboardExamineMyRef% = -1

WHEN 0
	REM YourRef 0 would be another application saving to us; we don't
	REM support this.

	PROCmain_wind_reset_proto
	PROCmain_wind_set_proto_message("NoSaveIn")

OTHERWISE
	PROCmain_wind_set_proto_error("BadYourRef", "DataSave")

	REM Not sure if we need this? Was it just for debugging IcnClipBrd?

	IF message%!24 = ClipboardInternalHandle% THEN
		ClipboardCurrentOwnerTask% = message%!4
		ClipboardCurrentType% = message%!40
		PROCmain_wind_set_content(FNstring_read(message%+44), FNclipboard_task_name_from_handle(message%!4), ClipboardCurrentType%)
	ENDIF
ENDCASE
ENDPROC


REM Handle an incoming Message_DataSaveAck.
REM
REM \param message%	Pointer to the Wimp_Poll block.
:
DEF PROCclipboard_message_data_save_ack(message%)
LOCAL flags%, sender_handle%, receiver_handle%, object%, size%, type%

CASE message%!12 OF
WHEN ClipboardDragSaveMyRef%
	REM We're saving the clipboard to another app, started in
	REM PROCclipboard_start_drag_save. Update the MyRef value.

	REM Clipboard Drag Save Step 2

	ClipboardDragSaveMyRef% = message%!8

	PROCmain_wind_set_proto_error("RecdAck")

	REM Ack the message whatever happens

	message%!12 = ClipboardDragSaveMyRef%			: REM Should we do this??
	SYS "Wimp_SendMessage", 19, message%, message%!4	: REM Is it required??

	REM Start the actual save process.

	PROCclipboard_save_data(FNstring_read(message% + 44), message%, TRUE)

	REM If we own the clipboard, send the ack now.

	IF ClipboardCurrentOwnerTask% = ClipperTaskHandle% THEN
		message%!12 = ClipboardDragSaveMyRef%
		message%!16 = 3 : REM Message_DataLoad
		SYS "Wimp_SendMessage", 17, message%, ClipboardSaveDestinationTask%
		ClipboardSaveDestinationTask% = -1
	ENDIF

WHEN ClipboardRequestMyRef%
	PROCclipboard_copy_file(ClipboardCurrentFile$, FNstring_read(message% + 44))
	sender_handle% = message%!4
	message%!12 = message%!8
	message%!16 = 3 : REM Message_DataLoad
	SYS "XOS_File", 23, ClipboardCurrentFile$ TO object%,,,,size%,,type% ;flags%
	IF (flags% AND %1) OR (object% <> 1) THEN
		PROCmain_wind_set_proto_error("BadClipFile")
		ClipboardRequestMyRef% = -1
	ELSE
		message%!36 = size%
		message%!40 = type%
		SYS "Wimp_SendMessage", 17, message%, sender_handle% TO ,,receiver_handle%

		ClipboardRequestMyRef% = message%!8
		PROCmain_wind_set_proto_param_message("OfferData", FNclipboard_task_name_from_handle(receiver_handle%))
	ENDIF

OTHERWISE
	PROCmain_wind_set_proto_error("BadYourRef", "DataSaveAck")
ENDCASE
ENDPROC


REM Handle an incoming Message_DataLoad.
REM
REM \param message%	Pointer to the Wimp_Poll block.
:
DEF PROCclipboard_message_data_load(message%)
LOCAL task$

CASE message%!12 OF
WHEN ClipboardSaveMyRef%
	IF ClipboardSaveDestinationTask% <> -1 THEN
		SaveDragFrom% = message%!4
		SaveFromRef% = message%!8

		REM Ack the message

		message%!12 = message%!8
		SYS "Wimp_SendMessage", 19, message%, SaveDragFrom%

		REM Pass message on to dest app

		message%!12 = ClipboardDragSaveMyRef%
		SYS "Wimp_SendMessage", 18, message%, ClipboardSaveDestinationTask% TO 

		REM Clipboard Drag Save Step 3

		ClipboardDragSaveMyRef% = message%!8
		PROCmain_wind_set_proto_param_message("AskToLoad", FNclipboard_task_name_from_handle(ClipboardSaveDestinationTask%))
	ENDIF

WHEN 0
	REM The filer is asking us to load a file.

	PROCmain_wind_reset_proto
	PROCmain_wind_set_proto_message("AskedToLoad")

	REM Send a Message_DataLoadAck back to the filer.

	message%!12 = message%!8
	message%!16 = 4 : REM Message_DataLoadAck
	SYS "Wimp_SendMessage", 17, message%, message%!4

	REM Record the details of what we currently own.

	ClipboardCurrentFile$ = FNstring_read(message% + 44)
	ClipboardCurrentOwnerTask% = ClipperTaskHandle%
	ClipboardCurrentType% = message%!40

	REM Send a Message_ClaimEntity to take ownership of the clipboard.

	q%!0 = 24
	q%!12 = 0
	q%!16 = &F	: REM Message_ClaimEntity
	q%!20 = %100	: REM Claiming the clipboard.
	SYS "Wimp_SendMessage", 17, q%, 0

	REM Update the display.

	PROCmain_wind_set_content(ClipboardCurrentFile$, TaskName$, ClipboardCurrentType%)
	PROCmain_wind_set_proto_message("ItsOurs")

OTHERWISE
	PROCmain_wind_set_proto_error("BadYourRef", "DataLoad")
ENDCASE
ENDPROC


REM Handle an incoming Message_DataLoadAck.
REM
REM \param message%	Pointer to the Wimp_Poll block.
:
DEF PROCclipboard_message_data_load_ack(message%)
CASE message%!12 OF
WHEN ClipboardDragSaveMyRef%
	IF ClipboardSaveDestinationTask% <> -1 THEN
		message%!12 = SaveFromRef%
		SYS "Wimp_SendMessage", 17, message%, SaveDragFrom%
		ClipboardSaveDestinationTask% = -1

		REM Clipboard Drag Save Step 4

		ClipboardDragSaveMyRef% = -1 : REM ???
	ENDIF

WHEN ClipboardRequestMyRef%
	PROCmain_wind_set_proto_message("Accepted")
	ClipboardRequestMyRef% = -1

OTHERWISE
	PROCmain_wind_set_proto_error("BadYourRef", "DataLoadAck")
ENDCASE
ENDPROC


REM Handle bounced DataSaveAck messages. Does this ever get used:
REM do we ever send a DataLoadAck? & This is actually a 3 bounce, not 4!

DEF PROCclipboard_message_data_load_ack_bounce(message%)
PROCmain_wind_set_proto_error("RecDied")
ClipboardSaveDestinationTask% = -1
ENDPROC


REM Handle bounced messages sent as part of the various protocols.
REM
REM \param message%	Pointer to the Wimp_Poll data block.
:
DEF PROCclipboard_message_bounce(message%)
CASE message%!8 OF
WHEN ClipboardDragSaveMyRef%
	REMCASE message%!16 OF


	REM Clipboard Drag Save Step 4

	ClipboardDragSaveMyRef% = -1
	PROCmain_wind_set_proto_message("NoInterest")

WHEN ClipboardExamineMyRef%
	REM A message sent to examine the clipboard bounced.

	REM Clipboard Examine Bounced

	ClipboardExamineMyRef% = -1

	REM If the message Message_DataRequest, clear the current clipboard data.

	IF message%!16 = &10 THEN
		ClipboardCurrentOwnerTask% = -1
		ClipboardCurrentType% = -1

		PROCmain_wind_set_content("None", "-", ClipboardCurrentType%)
		PROCmain_wind_set_proto_message("NoClipboard")
	ENDIF

WHEN ClipboardRequestMyRef%
	PROCmain_wind_set_proto_error("RecDied")
	ClipboardRequestMyRef% = -1
ENDCASE
ENDPROC


REM Initialise a save of the clipboard data to the given filename, which
REM will either be carried out immediately if we own the clipboard, or
REM by sending a Message_DataRequest to the owner if we don't.
REM
REM \param filename$	The filename to which to save the file.
REM \param message%	The block in which to build the message.
REM \param use_message%	Treat the message block as being the data from
REM			an earlier Message_DataSaveAck.

DEF PROCclipboard_save_data(filename$, message%, use_message%)
LOCAL message$, receiver_handle%

ClipboardSavePath$ = filename$

REM If this is a direct save, check that there's a full path name
REM present in the supplied filename.

IF (NOT use_message%) AND (INSTR(ClipboardSavePath$,".") = 0) THEN
	message$ = FNmessage_lookup("DragSave")
	PROCwimperror_report(message$, 1, %01, "")
	ENDPROC
ENDIF

REM If we own the clipboard, we can just copy our file to the destination.

IF ClipboardCurrentOwnerTask% = ClipperTaskHandle% THEN
	PROCclipboard_copy_file(ClipboardCurrentFile$, ClipboardSavePath$)
	ENDPROC
ENDIF

REM Otherwise, we need to send a Message_DataRequest to the clipboard
REM owner to request the clipboard data.

message%!0 = 44
message%!12 = 0
message%!16 = &10 : REM Message_DataRequest
IF NOT use_message% THEN
	message%!20 = -3
	message%!24 = ClipboardInternalHandle%
	message%!28 = 640
	message%!32 = 512
ENDIF
message%!36 = 4
message%!40 = -1
SYS "Wimp_SendMessage", 18, message%, ClipboardCurrentOwnerTask% TO ,,receiver_handle%
ClipboardSaveMyRef% = message%!8
PROCmain_wind_set_proto_param_message("AskToSave", FNclipboard_task_name_from_handle(receiver_handle%))
ENDPROC


REM Copy a file on disc, reporting any error via Wimp_ReportError.
REM
REM \param source$	The source file to be copied.
REM \param destination$	The destination of the copy operation.
:
DEF PROCclipboard_copy_file(source$, destination$)
LOCAL error%, flags%

SYS "XOS_FSControl", 26, source$, destination$, %10 TO error% ;flags%
IF flags% AND 1 THEN SYS "Wimp_ReportError", error%, &501, TaskName$, TaskSprite$, 1, 0
ENDPROC


REM Given a task handle, get the task name. Returns "???" if the
REM handle can not be resolved.
REM
REM \param handle%	The task handle to look up.
REM \return		The corresponding task name.
:
DEF FNclipboard_task_name_from_handle(handle%)
LOCAL name%, flags%

SYS "XTaskManager_TaskNameFromHandle",handle% TO name% ;flags%
IF flags% AND 1 THEN ="???"
=FNstring_read(name%)
